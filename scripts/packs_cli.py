#!/usr/bin/env python3
"""
Atrium Packs CLI: validate manifests, build distributable artifacts.

Usage:
  python scripts/packs_cli.py validate
  python scripts/packs_cli.py build
  python scripts/packs_cli.py serve
"""

from __future__ import annotations

import argparse
import hashlib
import json
import sys
import zipfile
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

REPO_ROOT = Path(__file__).resolve().parent.parent
PACKS_ROOT = REPO_ROOT / "atrium_packs"
DIST_ROOT = PACKS_ROOT / "dist"
DEFAULT_ALLOWED = ["PUBLIC_DOMAIN", "CC0", "CC BY 4.0", "CC BY-SA 4.0"]


def find_pack_dirs() -> List[Path]:
    """Find all pack directories (containing pack.json) under atrium_packs/*/packs/."""
    if not PACKS_ROOT.exists():
        return []
    dirs = []
    for path_dir in PACKS_ROOT.iterdir():
        if not path_dir.is_dir():
            continue
        packs_dir = path_dir / "packs"
        if not packs_dir.exists():
            continue
        for pack_dir in packs_dir.iterdir():
            if pack_dir.is_dir() and (pack_dir / "pack.json").exists():
                dirs.append(pack_dir)
    return sorted(dirs)


def load_pack(pack_dir: Path) -> Tuple[Optional[Dict], Optional[str]]:
    """Load pack.json. Returns (data, error)."""
    path = pack_dir / "pack.json"
    if not path.exists():
        return None, f"pack.json missing: {pack_dir}"
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f), None
    except json.JSONDecodeError as e:
        return None, f"Invalid JSON in {path}: {e}"


def validate_pack(pack_dir: Path, pack: Dict) -> List[str]:
    """Validate a pack. Returns list of error messages."""
    errors: List[str] = []
    pack_id = pack.get("pack_id", "?")
    allowed = pack.get("allowed_licenses", DEFAULT_ALLOWED)

    for key in ["pack_id", "version", "title", "path_id", "module", "books"]:
        if key not in pack:
            errors.append(f"[{pack_id}] Missing required field: {key}")

    if "module" in pack:
        mod = pack["module"]
        for key in ["id", "title", "order"]:
            if key not in mod:
                errors.append(f"[{pack_id}] Missing module.{key}")

    if "books" in pack:
        for i, book in enumerate(pack["books"]):
            prefix = f"[{pack_id}] books[{i}]"
            for key in ["source_file", "source_url", "license", "attribution"]:
                if key not in book:
                    errors.append(f"{prefix} Missing required field: {key}")

            if "license" in book:
                lic = book["license"]
                for key in ["type", "url", "proof_url"]:
                    if key not in lic:
                        errors.append(f"{prefix} license.{key} required")
                lic_type = lic.get("type")
                if lic_type and lic_type not in allowed:
                    errors.append(
                        f"{prefix} Disallowed license type: {lic_type} "
                        f"(allowed: {allowed})"
                    )

            if "source_file" in book:
                src = pack_dir / "sources" / book["source_file"]
                if not src.exists():
                    errors.append(f"{prefix} source_file not found: {book['source_file']}")

    lic_dir = pack_dir / "LICENSES"
    if pack.get("books") and not lic_dir.exists():
        errors.append(f"[{pack_id}] LICENSES/ directory missing (required when pack has books)")
    # attribution.json is generated by build; no need to fail validate

    return errors


def validate_all() -> int:
    """Validate all packs. Returns exit code (0=ok, 1=fail)."""
    pack_dirs = find_pack_dirs()
    if not pack_dirs:
        print("No packs found under atrium_packs/*/packs/")
        return 0

    all_errors: List[str] = []
    for pack_dir in pack_dirs:
        pack, load_err = load_pack(pack_dir)
        if load_err:
            all_errors.append(load_err)
            continue
        errs = validate_pack(pack_dir, pack)
        all_errors.extend(errs)

    if all_errors:
        print("Validation failed:")
        for e in all_errors:
            print(f"  - {e}")
        return 1
    print(f"Validated {len(pack_dirs)} pack(s) OK")
    return 0


def generate_attribution(pack: Dict) -> Dict[str, Any]:
    """Generate LICENSES/attribution.json from pack.json."""
    entries = []
    for book in pack.get("books", []):
        entries.append({
            "source_file": book.get("source_file"),
            "title": book.get("title"),
            "author": book.get("author"),
            "source_url": book.get("source_url"),
            "license": book.get("license"),
            "attribution": book.get("attribution"),
        })
    return {"pack_id": pack.get("pack_id"), "version": pack.get("version"), "books": entries}


def generate_third_party_notices(pack: Dict) -> str:
    """Generate THIRD_PARTY_NOTICES.txt (human-readable)."""
    lines = ["THIRD PARTY NOTICES", "=" * 40, ""]
    for book in pack.get("books", []):
        title = book.get("title", book.get("source_file", "Unknown"))
        lines.append(f"{title}")
        lines.append(f"  Attribution: {book.get('attribution', '')}")
        lic = book.get("license", {})
        lines.append(f"  License: {lic.get('type', '')} - {lic.get('url', '')}")
        lines.append("")
    return "\n".join(lines)


def build_pack(pack_dir: Path, pack: Dict, path_data: Optional[Dict], dist_base: Path) -> Dict[str, Any]:
    """Build a single pack: attribution, notices, zip. Returns catalog entry."""
    pack_id = pack.get("pack_id", "unknown")
    version = pack.get("version", "0.0.0")
    zip_name = f"{pack_id}-{version}.zip"
    zip_path = dist_base / "packs" / zip_name

    lic_dir = pack_dir / "LICENSES"
    lic_dir.mkdir(parents=True, exist_ok=True)

    att = generate_attribution(pack)
    att_path = lic_dir / "attribution.json"
    with open(att_path, "w", encoding="utf-8") as f:
        json.dump(att, f, indent=2, ensure_ascii=False)

    notices = generate_third_party_notices(pack)
    notices_path = lic_dir / "THIRD_PARTY_NOTICES.txt"
    notices_path.write_text(notices, encoding="utf-8")

    zip_path.parent.mkdir(parents=True, exist_ok=True)
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
        zf.write(pack_dir / "pack.json", "pack.json")
        if path_data:
            zf.writestr("path.json", json.dumps(path_data, indent=2))
        for p in (pack_dir / "sources").rglob("*") if (pack_dir / "sources").exists() else []:
            if p.is_file():
                zf.write(p, p.relative_to(pack_dir))
        for p in lic_dir.rglob("*"):
            if p.is_file():
                zf.write(p, p.relative_to(pack_dir))

    size = zip_path.stat().st_size
    sha = hashlib.sha256(zip_path.read_bytes()).hexdigest()

    licenses_summary = list({b.get("license", {}).get("type") for b in pack.get("books", []) if b.get("license")})

    return {
        "pack_id": pack_id,
        "version": version,
        "title": pack.get("title", ""),
        "description": pack.get("description", ""),
        "module": pack.get("module", {}),
        "prereqs": pack.get("module", {}).get("prereqs", []),
        "size_bytes": size,
        "sha256": sha,
        "download_url": f"packs/{zip_name}",
        "book_count": len(pack.get("books", [])),
        "licenses_summary": licenses_summary,
    }


def build_all() -> int:
    """Build all packs. Returns exit code."""
    pack_dirs = find_pack_dirs()
    if not pack_dirs:
        print("No packs found")
        return 0

    all_errors: List[str] = []
    for pack_dir in pack_dirs:
        pack, load_err = load_pack(pack_dir)
        if load_err:
            all_errors.append(load_err)
            continue
        errs = validate_pack(pack_dir, pack)
        all_errors.extend(errs)

    if all_errors:
        print("Validation failed (run validate first):")
        for e in all_errors:
            print(f"  - {e}")
        return 1

    dist_base = DIST_ROOT
    dist_base.mkdir(parents=True, exist_ok=True)
    (dist_base / "packs").mkdir(exist_ok=True)
    (dist_base / "paths").mkdir(exist_ok=True)

    catalog: List[Dict] = []
    path_cache: Dict[str, Dict] = {}

    for pack_dir in pack_dirs:
        pack, _ = load_pack(pack_dir)
        if not pack:
            continue

        path_id = pack.get("path_id")
        path_data = None
        if path_id:
            path_dir = pack_dir.parent.parent
            path_json = path_dir / "path.json"
            if path_json.exists() and path_id not in path_cache:
                try:
                    with open(path_json, "r") as f:
                        path_cache[path_id] = json.load(f)
                except Exception:
                    pass
            path_data = path_cache.get(path_id)
            if path_data:
                path_out = dist_base / "paths" / path_id
                path_out.mkdir(parents=True, exist_ok=True)
                with open(path_out / "path.json", "w") as f:
                    json.dump(path_data, f, indent=2)
                lp = path_dir / "learning_path.md"
                if lp.exists():
                    import shutil
                    shutil.copy2(lp, path_out / "learning_path.md")

        entry = build_pack(pack_dir, pack, path_data, dist_base)
        catalog.append(entry)


    catalog_path = dist_base / "catalog.json"
    with open(catalog_path, "w", encoding="utf-8") as f:
        json.dump(catalog, f, indent=2, ensure_ascii=False)

    print(f"Built {len(catalog)} pack(s) to {dist_base}")
    for e in catalog:
        print(f"  - {e['pack_id']}-{e['version']}.zip ({e['book_count']} books)")
    return 0


def serve_cmd() -> None:
    """Print instructions for serving dist."""
    print("To serve packs from your PC:")
    print()
    print(f"  cd {DIST_ROOT}")
    print("  python -m http.server 7777")
    print()
    print("Then configure frontend:")
    print("  NEXT_PUBLIC_PACKS_BASE=http://localhost:7777")
    print()
    print("Catalog URL: http://localhost:7777/catalog.json")


def main() -> int:
    parser = argparse.ArgumentParser(description="Atrium Packs CLI")
    sub = parser.add_subparsers(dest="cmd", required=True)
    sub.add_parser("validate", help="Validate all pack manifests")
    sub.add_parser("build", help="Build distributable artifacts")
    sub.add_parser("serve", help="Print serve instructions")
    args = parser.parse_args()

    if args.cmd == "validate":
        return validate_all()
    if args.cmd == "build":
        return build_all()
    if args.cmd == "serve":
        serve_cmd()
        return 0
    return 1


if __name__ == "__main__":
    sys.exit(main())
